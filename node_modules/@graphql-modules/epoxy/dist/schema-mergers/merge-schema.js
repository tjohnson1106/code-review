"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var utils_1 = require("./utils");
var merge_nodes_1 = require("./merge-nodes");
function mergeGraphQLSchemas(types) {
    return {
        kind: 'Document',
        definitions: mergeGraphQLTypes(types),
    };
}
exports.mergeGraphQLSchemas = mergeGraphQLSchemas;
function fixSchemaAst(schema) {
    return graphql_1.buildASTSchema(graphql_1.parse(graphql_1.printSchema(schema)));
}
function createSchemaDefinition(def) {
    var schemaRoot = {
        query: def.query && def.query.toString(),
        mutation: def.mutation && def.mutation.toString(),
        subscription: def.subscription && def.subscription.toString(),
    };
    var fields = Object.keys(schemaRoot)
        .map(function (rootType) { return (schemaRoot[rootType] ? rootType + ": " + schemaRoot[rootType] : null); })
        .filter(function (a) { return a; });
    if (fields.length) {
        return "schema { " + fields.join('\n') + " }";
    }
    return undefined;
}
function mergeGraphQLTypes(types) {
    var allNodes = types
        .map(function (type) {
        if (utils_1.isGraphQLSchema(type)) {
            var schema = type;
            var typesMap_1 = type.getTypeMap();
            var validAstNodes = Object.keys(typesMap_1).filter(function (key) { return typesMap_1[key].astNode; });
            if (validAstNodes.length === 0 && Object.keys(typesMap_1).length > 0) {
                schema = fixSchemaAst(schema);
                typesMap_1 = schema.getTypeMap();
            }
            var schemaDefinition_1 = createSchemaDefinition({
                query: schema.getQueryType(),
                mutation: schema.getMutationType(),
                subscription: schema.getSubscriptionType(),
            });
            var allTypesPrinted = Object.keys(typesMap_1)
                .map(function (key) { return typesMap_1[key]; })
                .map(function (type) { return (type.astNode ? graphql_1.print(type.astNode) : null); })
                .filter(function (e) { return e; });
            var directivesDeclaration = schema
                .getDirectives()
                .map(function (directive) { return (directive.astNode ? graphql_1.print(directive.astNode) : null); })
                .filter(function (e) { return e; });
            var printedSchema = tslib_1.__spread(directivesDeclaration, allTypesPrinted, [schemaDefinition_1]).join('\n');
            return graphql_1.parse(printedSchema);
        }
        else if (utils_1.isStringTypes(type) || utils_1.isSourceTypes(type)) {
            return graphql_1.parse(type);
        }
        return type;
    })
        .map(function (ast) { return ast.definitions; })
        .reduce(function (defs, newDef) { return tslib_1.__spread(defs, newDef); }, []);
    // XXX: right now we don't handle multiple schema definitions
    var schemaDef = allNodes.filter(utils_1.isSchemaDefinition).reduce(function (def, node) {
        node.operationTypes
            .filter(function (op) { return op.type.name.value; })
            .forEach(function (op) {
            def[op.operation] = op.type.name.value;
        });
        return def;
    }, {
        query: null,
        mutation: null,
        subscription: null,
    });
    var mergedNodes = merge_nodes_1.mergeGraphQLNodes(allNodes);
    var allTypes = Object.keys(mergedNodes);
    var queryType = schemaDef.query ? schemaDef.query : allTypes.find(function (t) { return t === 'Query'; });
    var mutationType = schemaDef.mutation ? schemaDef.mutation : allTypes.find(function (t) { return t === 'Mutation'; });
    var subscriptionType = schemaDef.subscription ? schemaDef.subscription : allTypes.find(function (t) { return t === 'Subscription'; });
    var schemaDefinition = createSchemaDefinition({
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
    });
    if (!schemaDefinition) {
        return Object.values(mergedNodes);
    }
    var def = graphql_1.parse(schemaDefinition).definitions[0];
    return tslib_1.__spread(Object.values(mergedNodes), [def]);
}
exports.mergeGraphQLTypes = mergeGraphQLTypes;
//# sourceMappingURL=merge-schema.js.map