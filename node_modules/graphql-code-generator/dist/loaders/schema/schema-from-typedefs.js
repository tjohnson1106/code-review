"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isGlob = require("is-glob");
var isValidPath = require("is-valid-path");
var chalk_1 = require("chalk");
var glob = require("glob");
var graphql_tools_1 = require("graphql-tools");
var fs_1 = require("fs");
var path = require("path");
var fs = require("fs");
var errors_1 = require("../../errors");
var documents_from_glob_1 = require("../documents/documents-from-glob");
function isGraphQLFile(globPath) {
    return documents_from_glob_1.graphQLExtensions.some(function (ext) { return globPath.endsWith(ext); });
}
function loadSchemaFile(filepath) {
    var content = fs.readFileSync(filepath, {
        encoding: 'utf-8'
    });
    if (/^\# import /i.test(content.trimLeft())) {
        var importSchema = require('graphql-import').importSchema;
        return importSchema(filepath);
    }
    return content;
}
var SchemaFromTypedefs = /** @class */ (function () {
    function SchemaFromTypedefs() {
    }
    SchemaFromTypedefs.prototype.canHandle = function (globPath) {
        return isGlob(globPath) || (isValidPath(globPath) && isGraphQLFile(globPath));
    };
    SchemaFromTypedefs.prototype.handle = function (globPath, config, schemaOptions) {
        var globFiles = glob.sync(globPath, { cwd: process.cwd() });
        if (!globFiles || globFiles.length === 0) {
            throw new errors_1.DetailedError('Unable to find matching files', "\n      \n        Unable to find matching files for glob: " + globPath + " in directory: " + process.cwd() + "\n      ");
        }
        var mergeLogic = function (arr) { return arr; };
        if ('mergeSchemaFiles' in config) {
            var patternArr = config.mergeSchemaFiles.split('#');
            var mergeModuleName = patternArr[0];
            var mergeFunctionName = patternArr[1];
            if (!mergeModuleName || !mergeFunctionName) {
                throw new errors_1.DetailedError("You have to specify your merge logic with 'mergeSchema' option", "\n\n          You have to specify your merge logic with 'mergeSchema' option.\n\n          The pattern is following:\n            \n            " + chalk_1.default.bold('path/to/file') + "#" + chalk_1.default.bold('merge') + "\n\n            - path/to/file - points to JavaScript module\n            - merge - name of exported function\n          \n          \n          CLI:\n\n            $ gql-gen --mergeSchema path/to/file#merge\n\n          API:\n\n            generate({\n              mergeSchema: 'path/to/file#merge',\n              ...\n            });\n\n        ");
            }
            var localFilePath = path.resolve(process.cwd(), mergeModuleName);
            var localFileExists = fs.existsSync(localFilePath);
            var mergeModule = require(localFileExists ? localFilePath : mergeModuleName);
            if (!(mergeFunctionName in mergeModule)) {
                throw new errors_1.DetailedError("Provided function couldn't be found", "\n        \n          Provided " + mergeFunctionName + " function couldn't be found in " + mergeModule + "\n\n          You probably forgot to export " + mergeFunctionName + " function\n\n            export const " + mergeFunctionName + " ...\n\n        ");
            }
            mergeLogic = mergeModule[mergeFunctionName];
        }
        var typeDefs = globFiles.length > 1
            ? mergeLogic(globFiles.map(function (filePath) { return fs_1.readFileSync(filePath, 'utf-8'); }))
            : loadSchemaFile(globFiles[0]);
        return graphql_tools_1.makeExecutableSchema({
            typeDefs: typeDefs,
            allowUndefinedInResolve: true,
            resolvers: {},
            resolverValidationOptions: { requireResolversForResolveType: false }
        });
    };
    return SchemaFromTypedefs;
}());
exports.SchemaFromTypedefs = SchemaFromTypedefs;
//# sourceMappingURL=schema-from-typedefs.js.map