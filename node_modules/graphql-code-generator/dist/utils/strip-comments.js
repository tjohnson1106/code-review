"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var babylon = require("babylon");
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014-2016, 2018, Jon Schlinkert.
 * Released under the MIT License.
 *
 */
var removeComment = function (str, comment, pos) {
    var nl = '';
    var isCommentLine = function (c) { return c.type === 'CommentLine'; };
    if (isCommentLine(comment)) {
        var before = str.slice(0, comment.start - pos.removed);
        var after = str.slice(comment.end - pos.removed);
        pos.removed += comment.end - comment.start - nl.length;
        return before + nl + after;
    }
    var isCommentBlock = function (c) { return c.type === 'CommentBlock'; };
    if (isCommentBlock(comment)) {
        var before = str.slice(0, comment.start - pos.removed);
        var after = str.slice(comment.end - pos.removed);
        pos.removed += comment.end - comment.start - nl.length;
        return before + nl + after;
    }
    return str;
};
var stripComments = function (input, options) {
    if (typeof input !== 'string') {
        throw new TypeError('expected a string');
    }
    var defaults = {
        // we shouldn't care about this here since our goal is to strip comments,
        // not transpiling, and this has been a common cause of parsing issues
        allowReturnOutsideFunction: true,
        // casting because @types/babylon hasn't updated to babylon@^7
        plugins: ['typescript', 'jsx']
    };
    var opts = __assign({}, defaults, options);
    var res = babylon.parse(input, opts);
    var comments = res.comments;
    var pos = { start: 0, end: 0, removed: 0 };
    if (!comments) {
        return input;
    }
    for (var _i = 0, comments_1 = comments; _i < comments_1.length; _i++) {
        var comment = comments_1[_i];
        input = removeComment(input, comment, pos);
    }
    return input;
};
exports.default = stripComments;
//# sourceMappingURL=strip-comments.js.map