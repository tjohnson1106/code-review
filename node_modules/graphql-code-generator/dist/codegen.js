"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_tools_1 = require("graphql-tools");
var Listr = require("listr");
var helpers_1 = require("./helpers");
var validate_documents_1 = require("./loaders/documents/validate-documents");
var prettier_1 = require("./utils/prettier");
var listr_renderer_1 = require("./utils/listr-renderer");
var errors_1 = require("./errors");
var load_1 = require("./load");
var merge_schemas_1 = require("./merge-schemas");
var graphql_1 = require("graphql");
function executeCodegen(config) {
    return __awaiter(this, void 0, void 0, function () {
        function wrapTask(task, source) {
            var _this = this;
            return function () { return __awaiter(_this, void 0, void 0, function () {
                var error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, task()];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            error_1 = _a.sent();
                            if (source && !(error_1 instanceof graphql_1.GraphQLError)) {
                                error_1.source = source;
                            }
                            throw error_1;
                        case 3: return [2 /*return*/];
                    }
                });
            }); };
        }
        function normalize() {
            /* Load Require extensions */
            var requireExtensions = helpers_1.normalizeInstanceOrArray(config.require);
            requireExtensions.forEach(function (mod) { return require(mod); });
            /* Root templates-config */
            rootConfig = config.config || {};
            /* Normalize root "schema" field */
            schemas = helpers_1.normalizeInstanceOrArray(config.schema);
            /* Normalize root "documents" field */
            documents = helpers_1.normalizeInstanceOrArray(config.documents);
            /* Normalize "generators" field */
            var generateKeys = Object.keys(config.generates);
            if (generateKeys.length === 0) {
                throw new errors_1.DetailedError('Invalid Codegen Configuration!', "\n        Please make sure that your codegen config file contains the \"generates\" field, with a specification for the plugins you need.\n        \n        It should looks like that:\n\n        schema:\n          - my-schema.graphql\n        generates:\n          my-file.ts:\n            - plugin1\n            - plugin2\n            - plugin3\n        ");
            }
            for (var _i = 0, generateKeys_1 = generateKeys; _i < generateKeys_1.length; _i++) {
                var filename = generateKeys_1[_i];
                generates[filename] = helpers_1.normalizeOutputParam(config.generates[filename]);
                if (generates[filename].plugins.length === 0) {
                    throw new errors_1.DetailedError('Invalid Codegen Configuration!', "\n          Please make sure that your codegen config file has defined plugins list for output \"" + filename + "\".\n          \n          It should looks like that:\n  \n          schema:\n            - my-schema.graphql\n          generates:\n            my-file.ts:\n              - plugin1\n              - plugin2\n              - plugin3\n          ");
                }
            }
            if (schemas.length === 0 && Object.keys(generates).some(function (filename) { return generates[filename].schema.length === 0; })) {
                throw new errors_1.DetailedError('Invalid Codegen Configuration!', "\n        Please make sure that your codegen config file contains either the \"schema\" field \n        or every generated file has its own \"schema\" field.\n        \n        It should looks like that:\n        schema:\n          - my-schema.graphql\n\n        or:\n        generates:\n          path/to/output:\n            schema: my-schema.graphql\n      ");
            }
        }
        function loadRootSchema() {
            return __awaiter(this, void 0, void 0, function () {
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!schemas.length) return [3 /*break*/, 3];
                            _a = merge_schemas_1.mergeSchemas;
                            return [4 /*yield*/, Promise.all(schemas.map(function (pointToScehma) { return load_1.loadSchema(pointToScehma, config); }))];
                        case 1: return [4 /*yield*/, _a.apply(void 0, [_b.sent()])];
                        case 2:
                            rootSchema = _b.sent();
                            _b.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        }
        function loadRootDocuments() {
            return __awaiter(this, void 0, void 0, function () {
                var _i, documents_1, docDef, documents_2, errors;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(documents.length > 0)) return [3 /*break*/, 5];
                            _i = 0, documents_1 = documents;
                            _a.label = 1;
                        case 1:
                            if (!(_i < documents_1.length)) return [3 /*break*/, 4];
                            docDef = documents_1[_i];
                            return [4 /*yield*/, load_1.loadDocuments(docDef, config)];
                        case 2:
                            documents_2 = _a.sent();
                            if (documents_2.length > 0) {
                                rootDocuments.push.apply(rootDocuments, documents_2);
                            }
                            _a.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4:
                            if (rootSchema) {
                                errors = validate_documents_1.validateGraphQlDocuments(rootSchema, rootDocuments);
                                validate_documents_1.checkValidationErrors(errors);
                            }
                            _a.label = 5;
                        case 5: return [2 /*return*/];
                    }
                });
            });
        }
        var result, commonListrOptions, listr, rootConfig, schemas, documents, generates, rootSchema, rootDocuments;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = [];
                    commonListrOptions = {
                        exitOnError: true
                    };
                    if (process.env.VERBOSE) {
                        listr = new Listr(__assign({}, commonListrOptions, { renderer: 'verbose', nonTTYRenderer: 'verbose' }));
                    }
                    else if (process.env.NODE_ENV === 'test') {
                        listr = new Listr(__assign({}, commonListrOptions, { renderer: 'silent', nonTTYRenderer: 'silent' }));
                    }
                    else {
                        listr = new Listr(__assign({}, commonListrOptions, { renderer: config.silent ? 'silent' : listr_renderer_1.Renderer, nonTTYRenderer: config.silent ? 'silent' : 'default', collapse: true, clearOutput: false }));
                    }
                    rootConfig = {};
                    generates = {};
                    rootDocuments = [];
                    listr.add({
                        title: 'Parse configuration',
                        task: function (ctx) {
                            normalize();
                            ctx.hasSchemas = schemas.length > 0;
                            ctx.hasDocuments = documents.length > 0;
                        }
                    });
                    listr.add({
                        title: 'Load schema',
                        enabled: function (ctx) { return ctx.hasSchemas; },
                        task: wrapTask(loadRootSchema)
                    });
                    listr.add({
                        title: 'Load documents',
                        enabled: function (ctx) { return ctx.hasDocuments; },
                        task: wrapTask(loadRootDocuments)
                    });
                    listr.add({
                        title: 'Generate outputs',
                        task: function () {
                            return new Listr(Object.keys(generates).map(function (filename, i) { return ({
                                title: "Generate " + filename,
                                task: function () {
                                    var outputConfig = generates[filename];
                                    var outputFileTemplateConfig = outputConfig.config || {};
                                    var outputSchema = rootSchema;
                                    var outputDocuments = rootDocuments;
                                    var outputSpecificSchemas = helpers_1.normalizeInstanceOrArray(outputConfig.schema);
                                    var outputSpecificDocuments = helpers_1.normalizeInstanceOrArray(outputConfig.documents);
                                    function addSchema() {
                                        return __awaiter(this, void 0, void 0, function () {
                                            var _a, _b, _c;
                                            return __generator(this, function (_d) {
                                                switch (_d.label) {
                                                    case 0:
                                                        _a = merge_schemas_1.mergeSchemas;
                                                        _c = (_b = [
                                                            rootSchema
                                                        ]).concat;
                                                        return [4 /*yield*/, Promise.all(outputSpecificSchemas.map(function (pointToScehma) { return load_1.loadSchema(pointToScehma, config); }))];
                                                    case 1: return [4 /*yield*/, _a.apply(void 0, [_c.apply(_b, [(_d.sent())])])];
                                                    case 2:
                                                        outputSchema = _d.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        });
                                    }
                                    function addDocuments() {
                                        return __awaiter(this, void 0, void 0, function () {
                                            var additionalDocs, _i, outputSpecificDocuments_1, docDef, documents_3, errors;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        additionalDocs = [];
                                                        _i = 0, outputSpecificDocuments_1 = outputSpecificDocuments;
                                                        _a.label = 1;
                                                    case 1:
                                                        if (!(_i < outputSpecificDocuments_1.length)) return [3 /*break*/, 4];
                                                        docDef = outputSpecificDocuments_1[_i];
                                                        return [4 /*yield*/, load_1.loadDocuments(docDef, config)];
                                                    case 2:
                                                        documents_3 = _a.sent();
                                                        if (documents_3.length > 0) {
                                                            additionalDocs.push.apply(additionalDocs, documents_3);
                                                        }
                                                        _a.label = 3;
                                                    case 3:
                                                        _i++;
                                                        return [3 /*break*/, 1];
                                                    case 4:
                                                        if (outputSchema) {
                                                            errors = validate_documents_1.validateGraphQlDocuments(outputSchema, additionalDocs);
                                                            validate_documents_1.checkValidationErrors(errors);
                                                        }
                                                        outputDocuments = rootDocuments.concat(additionalDocs);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        });
                                    }
                                    function doGenerateOutput() {
                                        return __awaiter(this, void 0, void 0, function () {
                                            var normalizedPluginsArray, output;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        normalizedPluginsArray = helpers_1.normalizeConfig(outputConfig.plugins);
                                                        return [4 /*yield*/, generateOutput({
                                                                filename: filename,
                                                                plugins: normalizedPluginsArray,
                                                                schema: outputSchema,
                                                                documents: outputDocuments,
                                                                inheritedConfig: __assign({}, rootConfig, outputFileTemplateConfig),
                                                                pluginLoader: config.pluginLoader || require
                                                            })];
                                                    case 1:
                                                        output = _a.sent();
                                                        result.push(output);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        });
                                    }
                                    return new Listr([
                                        {
                                            title: 'Add related schemas',
                                            enabled: function () { return outputSpecificSchemas.length > 0; },
                                            task: wrapTask(addSchema, filename)
                                        },
                                        {
                                            title: 'Add related documents',
                                            enabled: function () { return outputSpecificDocuments.length > 0; },
                                            task: wrapTask(addDocuments, filename)
                                        },
                                        {
                                            title: 'Generate',
                                            task: wrapTask(doGenerateOutput, filename)
                                        }
                                    ], {
                                        // it stops when one of tasks failed
                                        exitOnError: true
                                    });
                                }
                            }); }), {
                                // it doesn't stop when one of tasks failed, to finish at least some of outputs
                                exitOnError: false,
                                // run 4 at once
                                concurrent: 4
                            });
                        }
                    });
                    return [4 /*yield*/, listr.run()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.executeCodegen = executeCodegen;
function generateOutput(options) {
    return __awaiter(this, void 0, void 0, function () {
        var output, _i, _a, plugin, name_1, pluginConfig, result, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    output = '';
                    _i = 0, _a = options.plugins;
                    _c.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                    plugin = _a[_i];
                    name_1 = Object.keys(plugin)[0];
                    pluginConfig = plugin[name_1];
                    return [4 /*yield*/, executePlugin({
                            name: name_1,
                            config: typeof pluginConfig !== 'object'
                                ? pluginConfig
                                : __assign({}, options.inheritedConfig, pluginConfig),
                            schema: options.schema,
                            documents: options.documents,
                            outputFilename: options.filename,
                            allPlugins: options.plugins,
                            pluginLoader: options.pluginLoader
                        })];
                case 2:
                    result = _c.sent();
                    output += result;
                    _c.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    _b = { filename: options.filename };
                    return [4 /*yield*/, prettier_1.prettify(options.filename, output)];
                case 5: return [2 /*return*/, (_b.content = _c.sent(), _b)];
            }
        });
    });
}
exports.generateOutput = generateOutput;
function getPluginByName(name, pluginLoader) {
    return __awaiter(this, void 0, void 0, function () {
        var possibleNames, _i, possibleNames_1, packageName, possibleNamesMsg;
        return __generator(this, function (_a) {
            possibleNames = [
                "graphql-codegen-" + name,
                "graphql-codegen-" + name + "-template",
                "codegen-" + name,
                "codegen-" + name + "-template",
                name
            ];
            for (_i = 0, possibleNames_1 = possibleNames; _i < possibleNames_1.length; _i++) {
                packageName = possibleNames_1[_i];
                try {
                    return [2 /*return*/, pluginLoader(packageName)];
                }
                catch (err) {
                    if (err.message.indexOf("Cannot find module '" + packageName + "'") === -1) {
                        throw new errors_1.DetailedError("Unable to load template plugin matching " + name, "\n            Unable to load template plugin matching '" + name + "'.\n            Reason: \n              " + err.message + "\n          ");
                    }
                }
            }
            possibleNamesMsg = possibleNames
                .map(function (name) {
                return ("\n      - " + name + "\n  ").trimRight();
            })
                .join('');
            throw new errors_1.DetailedError("Unable to find template plugin matching " + name, "\n      Unable to find template plugin matching '" + name + "'\n      Install one of the following packages:\n      \n      " + possibleNamesMsg + "\n    ");
        });
    });
}
exports.getPluginByName = getPluginByName;
function executePlugin(options) {
    return __awaiter(this, void 0, void 0, function () {
        var pluginPackage, schema, _a, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, getPluginByName(options.name, options.pluginLoader)];
                case 1:
                    pluginPackage = _b.sent();
                    if (!pluginPackage || !pluginPackage.plugin || typeof pluginPackage.plugin !== 'function') {
                        throw new errors_1.DetailedError("Invalid Custom Plugin \"" + options.name + "\"", "\n      Plugin " + options.name + " does not export a valid JS object with \"plugin\" function.\n\n      Make sure your custom plugin is written in the following form:\n\n      module.exports = {\n        plugin: (schema, documents, config) => {\n          return 'my-custom-plugin-content';\n        },\n      };\n      ");
                    }
                    if (!!pluginPackage.addToSchema) return [3 /*break*/, 2];
                    _a = options.schema;
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, merge_schemas_1.mergeSchemas([
                        options.schema,
                        graphql_tools_1.makeExecutableSchema({
                            typeDefs: pluginPackage.addToSchema,
                            allowUndefinedInResolve: true,
                            resolverValidationOptions: {
                                requireResolversForResolveType: false,
                                requireResolversForAllFields: false,
                                requireResolversForNonScalar: false,
                                requireResolversForArgs: false
                            }
                        })
                    ])];
                case 3:
                    _a = _b.sent();
                    _b.label = 4;
                case 4:
                    schema = _a;
                    if (!(pluginPackage.validate && typeof pluginPackage.validate === 'function')) return [3 /*break*/, 8];
                    _b.label = 5;
                case 5:
                    _b.trys.push([5, 7, , 8]);
                    return [4 /*yield*/, pluginPackage.validate(schema, options.documents, options.config, options.outputFilename, options.allPlugins)];
                case 6:
                    _b.sent();
                    return [3 /*break*/, 8];
                case 7:
                    e_1 = _b.sent();
                    throw new errors_1.DetailedError("Plugin \"" + options.name + "\" validation failed:", "\n          " + e_1.message + "\n        ");
                case 8: return [2 /*return*/, pluginPackage.plugin(schema, options.documents, options.config)];
            }
        });
    });
}
exports.executePlugin = executePlugin;
//# sourceMappingURL=codegen.js.map